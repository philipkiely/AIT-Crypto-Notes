For any K1, K2, does there exist K3 such that DESK2(DESK1(X)) = DESK3(X)? It was formally proven that this is not true. Basically, the possible permutations that the cypher allows, 2^k, is a subset of the possible permutations of 2^n elements, which is (2^n)!, an immensely larger figure. Thus, the second encryption (or third, or further subsequent encryption) brings the output into a family of permutations that is unavailible to the original key, thus we cannot say that K3 exists that satisfies our criteria.

How, in practice, can we use a block cypher to encrypt a message that is longer (like a file) or shorter (like a keystroke) than the block size? Block Cypher Usage Modes.

Basic modes include:

* Electronic Codebook Mode (ECB)
* Cypher Block Chaining mode (CBC)
* Counter mode (CTR)
* Cypher feedback mode (CFB)
* Output feedback mode (OFB)

ECB splits long files into chunks of size equal to the block size, encrypts them separately using the same key (for performance reasons), then concatenates them. To decrypt, split to reverse the concat, decrypt, then concat to reverse the split.

ECB is not secure for long messages. If the entire block repeats, such as an all-whitespace block, or an image, or a linux binary with huge amounts of zeros. These equal plaintext blocks output equal cyphertext blocks, which shows information about the message.

See: Linux penguin image showing what information can come from just patterns.

ECB is okay for short messages, one block in size or so.

CBC is a more randomizing encryption mode with a similar scheme to ECB. Take the message, divide it into blocks. Encrypt the first block, then xor the encrypted first block with the next block, then encrypt that block. Continue until all blocks are encoded. This creates a message that is fully “noise,” all “signal” is obfuscated. To decode, reverse by xoring with following block.

CBC is the scheme to know. Y = Ek(Xi xor Yi-1)

Encrypting the same file twice with a different intitial value (IV) will result in a completely different outcome, as each xor affects the next xor. The initial value is also necessary to properly decode, as it xors with the first block. The initial value itself does not need to be secret, unlike the key. 

Single-bit errors will destroy their entire block, then destroy one bit in the next block, then nothing more.

Flipping one bit of the IV will affect that block of the plaintext. This targeted manipulation can destroy the integrety of the message. The IV can be known but must be unpredictable, generated by a cryptographic (non-standard) random number generator. The IV may also be sent encrypted using ECB encryption, which itself does not need an IV, as it is just one block. Otherwise, the IV may be a nonce (number used once).

Precomputation is making an encryption calculation before seeing the plaintext you need to encrypt. Precomputation is not possible in CBC because each block relies on the previous block for xor.

Padding is needed when the length of the message is not a multiple of the block length, and the last (or only) block is shorter than the block size. The padding must be removed by the receiver, so a full multiple will have a full block of padding appended. It is possible that the message is a full block size and may end with exacly the padding bytes, which would be removed, removing part of the message.

Have the padding be the number of padding bytes, repeated, so by examining the last block you can count back N blocks, make sure they are the same, and remove them. Thus, even if the message itself ends with a valid padding, there will be further padding and only that will be removed.

CTR again splits the message into blocks. It takes a counter, encrypts the counter, and xors that counter with the plaintext to get the cypher text. It then increments the counter, and continues. In this way, it is like a stream cypher as it has an internal state (the counter) and an update algorithm (incrementing), and this is basically a key stream. For decoding, just as with stream cyphers we need the same keystream.

CTR does not require padding as it can truncate the last block and xor that with the remainder plaintext.

It is crutial that counter values do not repeat within a message or between messages. Split the counter into two parts, the first is message specific, the second is incremented within a given message. 

Again, CTR does not provide integrity protection. 

CTR allows precomputation because the counters themselves are encrypted before they are xored with the plaintext. This makes it fast, as xoring is a fast operation.

CTR easily allows parallelization, as the message can be split and given with a range of counters.

Random access is also a property of CTR.

The encryption and decryption use the same “E” process, as it encrypts the key to get the xor, which is the same on encrypt and decrypt, and in most encryption algorithms E is faster than D, it is optimized for encryption.

These properties (precomputation, parallelization, random access, no inverse encryption function needed) make CTR a fast and practical encryption method.

In Summary:

* ECB is used for a single plaintext block, like an AES key or an IV
* CBC is a repeated use of the block cypher to unpredictably encrypt long messages
* CTR (and CFB and OFB) convert block cyphers to stream cyphers, and have various properties

Which one to pick depends on the use case and which properties are most important to have for the given application.

No mode provides integrity protection. In CBC, the encrypted message is longer than clear message due to padding.